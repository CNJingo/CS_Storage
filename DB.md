# DB


### DB는 데이터를 어떻게 저장해놓을까
<details>
   <summary> 자세히 보기 </summary>
 
 <br>

우리가 DB에서 데이터를 조회하면 테이블 구조의 형태의 데이터를 만나게 될 것이다. 하지만 결국 이 또한 table에 대한 메타데이터와 로우데이터가 만나서 논리적으로 우리에게 테이블이라는 형태로 데이터가 보여지는 것이다.



mysql에서  `SHOW VARIABLES LIKE 'datadir';` 이라는 명령어를 치면 메타데이터와 데이터가 존재하는 파일의 위치를 알 수 있다. 여기서 확장자명이 .frm인 것은 테이블의 포맷을 담고 있고 확장자 명이 .ibd인 것은 테이블의 데이터들을 담고 있다.



DB는 기본적으로 트리형태로 데이터를 관리하고 있다. 일반적으로 B tree라는 것으로 데이터를 관리하고 있다. 

<img width="1963" alt="스크린샷 2022-06-27 오전 1 03 39" src="https://user-images.githubusercontent.com/55564829/175823167-acd8aeaf-196b-4553-9448-b8efd39b4dfc.png">


리프노드를 데이터 페이지라고 부르는데 이 데이터 페이지들이 실질적인 디비의 데이터들을 담고 있다. B tree는 clustered 인덱스로 구성되어 있으며 clustered 인덱스로 구성되어 있다는 것은 즉 데이터가 순차적으로 저장되어 있다는 것이다. 



이러한 구조에서는 데이터를 찾아가는 과정에 있어서 full table scan이 필요 없이 바로 원하는 데이터 페이지를 찾아갈 수 있다는 장점이 있다. 즉 엄청나게 느린 작업인 disk I/O를 줄여서 데이터를 찾는 작업을 최적화 시킨 것이다.

</details>

### DB transaction이란?
<details>
   <summary> 자세히 보기 </summary>
 
 <br>
DB transaction이란 데이터베이스의 일관성을 유지하기 위해서 완전히 실행되거나 완전히 실패해야하는 작업을 얘기한다.
   
트랜잭션의 내용은 script형태로 되어있다. 절차적으로 작업들을 순차적으로 실행하는 것이다. 
   
이 작업들의 시작부터 끝을 하나의 단위로 생각하고 이 하나의 단위는 온전하게 실행되어야지만 commit하는 것이다.
      
이러한 특성을 원자성이라고 부른다.

하나의 단위에 속해있는 작업이 하나라도 실패하면 모든 작업을 되돌리는 rollback작업이 반드시 필요하다.
      
트랜잭션의 일관성이란 데이터 베이스를 만들때 미리 정의해놓은 일련의 규칙에 대해서 이 규칙을 위배하는 데이터는 받아들이지 않는 것을 의미한다.
      
데이터 베이스는 트랜잭션에 의해서 변경이 야기될 때 바로 그 변경이 디스크에 반영되는 것이 아니라 메모리에 반영이된다(inno DB 스토리지 엔진같은 경우 버퍼풀에 해당된다). 그래서 디비 롤백이 된다는 것은 매모리에 저장되어 있던 변경된 데이터들을 지우는 것이다.

트랜잭션이 완료되면 메모리 내용을 디스크에 반영해야되는데 이 것을 commit이라고 부른다.
      
데이터베이스에는 격리성이라는 특징이 있는데 이는 트랜잭션이 동시에 발생했을때 정해진 규칙에 따라서 얼만큼 영향을 받게할 것인지를 결정하는 것이다.
      
그렇다면 정해진 규칙이란 무엇이냐? 바로 여기서 격리 레벨의 개념이 나온다.
      
격리 레벨에는 총 4가지가 있다. READ_UNCOMMITED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE. (격리 수준이 낮은 순부터 나열한 것이다)
      
격리 수준은 높아질수록 동시성을 제한하기 때문에 성능이 저하되는 이슈를 가지고 있다. 하지만 보안성이나 데이터 privacy는 낮아질 수 있다.
     
일관된 읽기를 지원하기 위해서 잠금을 걸지 않고 읽기 작업을 수행할 수 있다. 잠금을 걸지 않는 다는 의미는 읽기 작업이 다른 트랜잭션의 잠금을 기다리지 않고 읽기 작업이 가능 즉 동시에 여러개의 트랜잭션이 작동할 수 있다는 것이다. (SERIALIZABLE에서는 불가능)
      
여기서는 격리수준에 따라서 어떤 데이터를 읽어오느냐가 달라지게 된다.
      
READ_UNCOMMITED는 커밋되지 않는 dirty데이터를 읽어온다.
      
READ_COMMITED는 커밋된 데이터만을 읽어온다.
      
REPEATABLE_READ는 커밋된 데이터만을 읽어오는 것은 물론 한 트랜잭션 내에서 같은 row에 대해서 read를 반복적으로 진행할때 항상 같은 데이터를 가져온다는 것을 보장해준다. 
     
      
</details>
