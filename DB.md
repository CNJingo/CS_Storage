# DB


### DB는 데이터를 어떻게 저장해놓을까
<details>
   <summary> 자세히 보기 </summary>
 
 <br>

   우리가 DB에서 데이터를 조회하면 테이블 구조의 형태의 데이터를 만나게 될 것이다. 하지만 결국 이 또한 table에 대한 메타데이터와 로우데이터가 만나서 논리적으로 우리에게 테이블이라는 형태로 데이터가 보여지는 것이다.



   mysql에서  `SHOW VARIABLES LIKE 'datadir';` 이라는 명령어를 치면 메타데이터와 데이터가 존재하는 파일의 위치를 알 수 있다. 여기서 확장자명이 .frm인 것은 테이블의 포맷을 담고 있고 확장자 명이 .ibd인 것은 테이블의 데이터들을 담고 있다.



   DB는 기본적으로 트리형태로 데이터를 관리하고 있다. 일반적으로 B tree라는 것으로 데이터를 관리하고 있다. 

   <img width="1963" alt="스크린샷 2022-06-27 오전 1 03 39" src="https://user-images.githubusercontent.com/55564829/175823167-acd8aeaf-196b-4553-9448-b8efd39b4dfc.png">


   리프노드를 데이터 페이지라고 부르는데 이 데이터 페이지들이 실질적인 디비의 데이터들을 담고 있다. B tree는 clustered 인덱스로 구성되어 있으며 clustered 인덱스로 구성되어 있다는 것은 즉 데이터가 순차적으로 저장되어 있다는 것이다. 



   이러한 구조에서는 데이터를 찾아가는 과정에 있어서 full table scan이 필요 없이 바로 원하는 데이터 페이지를 찾아갈 수 있다는 장점이 있다. 즉 엄청나게 느린 작업인 disk I/O를 줄여서 데이터를 찾는 작업을 최적화 시킨 것이다.

</details>

### DB transaction이란?
<details>
   <summary> 자세히 보기 </summary>
 
 <br>
   DB transaction이란 데이터베이스의 일관성을 유지하기 위해서 완전히 실행되거나 완전히 실패해야하는 작업을 얘기한다.

   트랜잭션의 내용은 script형태로 되어있다. 절차적으로 작업들을 순차적으로 실행하는 것이다. 

   이 작업들의 시작부터 끝을 하나의 단위로 생각하고 이 하나의 단위는 온전하게 실행되어야지만 commit하는 것이다.

   이러한 특성을 원자성이라고 부른다.

   하나의 단위에 속해있는 작업이 하나라도 실패하면 모든 작업을 되돌리는 rollback작업이 반드시 필요하다.

   트랜잭션의 일관성이란 데이터 베이스를 만들때 미리 정의해놓은 일련의 규칙에 대해서 이 규칙을 위배하는 데이터는 받아들이지 않는 것을 의미한다.

   데이터 베이스는 트랜잭션에 의해서 변경이 야기될 때 바로 그 변경이 디스크에 반영되는 것이 아니라 메모리에 반영이된다(inno DB 스토리지 엔진같은 경우 버퍼풀에 해당된다). 그래서 디비 롤백이 된다는 것은 매모리에 저장되어 있던 변경된 데이터들을 지우는 것이다.

   트랜잭션이 완료되면 메모리 내용을 디스크에 반영해야되는데 이 것을 commit이라고 부른다.

   데이터베이스에는 격리성이라는 특징이 있는데 이는 트랜잭션이 동시에 발생했을때 정해진 규칙에 따라서 얼만큼 영향을 받게할 것인지를 결정하는 것이다.

   그렇다면 정해진 규칙이란 무엇이냐? 바로 여기서 격리 레벨의 개념이 나온다.

   격리 레벨에는 총 4가지가 있다. READ_UNCOMMITED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE. (격리 수준이 낮은 순부터 나열한 것이다)

   격리 수준은 높아질수록 동시성을 제한하기 때문에 성능이 저하되는 이슈를 가지고 있다. 하지만 보안성이나 데이터 privacy는 낮아질 수 있다.

   일관된 읽기를 지원하기 위해서 잠금을 걸지 않고 읽기 작업을 수행할 수 있다. 잠금을 걸지 않는 다는 의미는 읽기 작업이 다른 트랜잭션의 잠금을 기다리지 않고 읽기 작업이 가능 즉 동시에 여러개의 트랜잭션이 작동할 수 있다는 것이다. (SERIALIZABLE에서는 불가능)

   여기서는 격리수준에 따라서 어떤 데이터를 읽어오느냐가 달라지게 된다.

   READ_UNCOMMITED는 커밋되지 않는 dirty데이터를 읽어온다.

   READ_COMMITED는 커밋된 데이터만을 읽어온다.

   REPEATABLE_READ는 커밋된 데이터만을 읽어오는 것은 물론 한 트랜잭션 내에서 같은 row에 대해서 read를 반복적으로 진행할때 항상 같은 데이터를 가져온다는 것을 보장해준다. 

      
</details>


### 데이터베이스 이상 현상이란?
<details>
   <summary> 자세히 보기 </summary>
 
 <br>
   데이터베이스의 정규화가 제대로 되어 있지 않았을때 의도한 대로 데이터 조작이 안되는 현상을 말한다.

   데이터베이스가 제대로 정규화 되어 있지 않다면 중복 데이터들이 존재할 가능성이 높고 이는 삽입, 수정, 삭제를 할때 문제를 발생시킬 수 있다는 점이다.

   삽입에 관련해서는 당장 존재하지 않는 데이터를 넣어야하는 오류가 발생할 수가 있다. 예를 들어 학생이 수강하고 있는 강의를 넣고 싶다고 가정할때 신규 학생이 들어왔지만 아직 수강중인 강의가 없을 때 이를 임의로 채워넣어서 데이터를 삽입해야 하는 상황이 발생한다. 이럴 경우 학생의 학적정보와 강의 정보를 분리한다면 해결할 수 있는 문제일 것이다.

   삭제에 관련해서는 내가 의도하지 않은 다른 row까지 삭제할 수 있다는 위험이 있습니다. 이는 중복된 데이터가 존재하기 떄문에 특정 칼럼을 조건으로 건다면 해당 칼럼을 중복으로 가지고 있는 여러 row들이 삭제될 것입니다.

   업데이트는 중복된 데이터가 존재하면 그중 하나의 데이터만 업데이트 됐을시에 데이터들 사이에 불일치가 발생할 수 있습니다.
   
   데이터 베이스의 정규화는 하지만 반드시 필요한 것은 아닙니다. 상황에 따라서 불필요한 경우가 생길 수도 있습니다. 
   
   자주 Select되는 데이터에 대해서 계속해서 조인이 필요한 상황이라고 한다면 서로 다른 disk block에 있는 데이터를 가져오기 위해서 성능이 느린 disk i/o가 발생할 것이고 이는 성능 저하를 일으킬 수 있습니다. 
   
   이럴때 자주 읽어져 오는 데이터에 대해서 비정규화를 하여 조인을 하지 않고도 데이터를 가져올 수 있게끔 하는 전략이 필요할때도 있습니다. 정규화라는 것은 그래서 상황에 따라 필요할 수도 필요하지 않을 수도 있습니다.


   
   
   
   
   
</details>
