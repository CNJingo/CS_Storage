# 운영체제


   
   
</details>

### non blocking vs blocking & sync vs asnyc
<details>
   <summary> 자세히 보기 </summary>
 
 <br>
   blocking과 non-blocking의 주요한 차이는 제어권을 가지고 있느냐 호출한 함수에게 넘기느냐 입니다.
  
  제어권을 호출한 함수에게 넘기게 된다면 호출자는 호출한 함수가 끝날때까지 기다려야 합니다.
  
  하지만 non blocking은 제어권을 넘기지 않기 때문에 해당 함수를 호출해놓고 본인이 해야될 일을 그대로 진행할 수 있습니다.
  
  sync와 async는 결과의 처리관점에서 보면 됩니다.
  
  sync는 호출한 함수가 반환한 결과를 바로 처리해야 하지만 asnyc같은 경우 호출한 함수의 결과값을 그 즉시 처리해도 되고 안해도 됩니다.
  
</details>

### process란?
<details>
   <summary> 자세히 보기 </summary>
 
 <br>
   프로세스란?

프로세스가 존재하기전에 프로그램이 존재한다.

프로그램을 실행했을때 프로그램의 인스턴스가 프로세스이다.

운영체제 입장에서는 프로세스화 시켜서 실행시킨다

이를 개념적으로 Task라고 한다.

컴퓨터에는 여러가지 프로세스들이 실행되고 있다.

이것들을 확인해보면 각각의 프로세스는 양의 정수로 이루어진 PID를 가지고 있다.

실행을 한다는 것을 일을 처리하는 것으로 볼 수 있다.

보통 운영체제는 여러개의 프로세스를 사용한다. 이 것을 Multi-tasking이라고 한다.

CPU에서 핀 하나가 전선 한가닥이다. 전기가 흐르면 1 전기가 흐르지 않으면 0이다. 그럼 핀 32개를 묶으면 32비트가 되는 것이다. 32비트에서 그런 어떤 곳엔 전기를 주고 어떤 곳엔 안주면 0010011...의 이진수 묶음이 생길 것이다. 입력을 담당하는 핀과 출력을 담당하는 핀도 존재한다. 입력을 받아서 특정한 연산을 쭉 해서 출력하는 것이 프로그램이다.

해당 연산들의 묶음을 하드디스크에 갖고 있으면 프로그램이고 그것을 복사해서 메모리에 올려서 진짜 연산을 시작하는 행위를 소위 '실행' 이라고 얘기한다.

프로그램이 실행하기 위해서는 커널을 통해서 필요한 하드웨어 자원을 할당받는다.

CPU와 램메모리의 일부를 할당 받게 된다. 만약 추가적으로 메모리 공간이 필요하다면 OS가 추가적인 메모리를 선택해서 준다. 이는 연속적이지 않을 수 있다.

	그리고 프로세스와 커널을 격리시키면 이것이 도커 컨테이너가 되는 것이다.

</details>

### system call
<details>
   <summary> 자세히 보기 </summary>
 
 <br>
	
컴퓨터는 유저모드, 커널모드, 하드웨어단 이렇게 세가지로 크게 범주화시킬 수 있다. 유저모드에서는 보통 시스템콜을 wrapping한 함수를 사용하여 시스템 콜을 호출하게 된다. 시스템콜을 호출하는 이유는 유저모드에서는 몇몇 명령어에 대한 권한이 없기 떄문이다. 예를 들면 memory read, write, jump to address와 같은 명령어들이다. 이러한 명령어는 커널모드에게 요청해서 커널이 대신 실행하게 해야한다. 이때 사용하는 것이 바로 시스템콜이다.

시스템 콜을 사용하면 CPL(Current Privilege Level)이라고 불리는 2비트 flag가 CS register에 저장돼있다. 이 CS register의 값이 3이면 유저모드, 0이면 커널모드이기 때문에 시스템콜이 발생하면 이 값을 0으로 바꾼다.
	
그 다음 스텍 세그먼트가 더이상 유저 스택을 가르키지 않는다. 스택에는 두 개의 공간이 나워져있는데 하나는 유저 모드 스택이고 하나는 커널 모드 스택이다. 
	
기본적으로 이는 커널모드에서 사용하는 정보와 유저모드를 구분해서 보호하기 위함이다. 이 것을 흔히 듀얼모드라고 부른다. 사용자모드와 커널모드를 나눠논 것을 얘기한다. 유저모드에서 privilieged instruction을 실행하는 것을 막아서 시스템을 보호한다.

이렇게 유저모드에서 커널모드로 변경시키는 작업을 인터럽트를 통해서 진행한다.

인터럽트는 IDT라는 interrupt descriptor table에 의해서 처리된다. 

IDT는 인터럽트와 인터럽트가 발생했을때 OS가 실행해야될 function이 맵핑되어 있다.

시스템 콜을 발생시키기 위해 x86 cpu는 int $0x80 명령어를 실행시킨다. int는 인터럽트를 뜻하며 0x80은 idt table의 위치를 나타낸다.

그리고 시스템콜 호출이 일반적인 함수호출과 다른 한가지 중요한 점은 일반적인 함수호출은 argument를 스택에 보내는 반면 시스템콜은 유저모드와 다른 스택을 사용하기 떄문에 이러한 방법이 불가능하다. 그렇기 떄문에 시스템 콜의 argument는 register에 저장한다. 만약 레지스터개수보다 파라미터 개수가 많다면 파라미터가 저장된 블록의 주소를 레지스터로 전달한다.

시스템 콜에는 다섯가지 종류가 존재한다.

Process control 
- 프로세스 종료와 생성
- 프로그램 로드 및 실행
- Wait 그리고 Signal event
- free memory 할당

File Management
- 파일 생성과 삭제, 열고 닫기, read / write, 파일 특성 가져오기

Device Management
- 디바이스에 요청하기
- 논리적으로 디바이스와 연결 또는 연결해제 하기
- 디바이스 특성 가져오기

Information Maintenance
- 시간 설정 및 가져오기
- 프로세스나 디바이스의 특성 가져오기

Communications
- connection 생성
- 메시지 주고 받기
- remote device와 연결 또는 해제하기



	



	
<img width="1365" alt="스크린샷 2022-12-11 오전 11 54 08" src="https://user-images.githubusercontent.com/55564829/206884132-5ada8bb7-6973-4861-84da-6b1e663eefdb.png">

 
</details>




### interrupt
<details>
   <summary> 자세히 보기 </summary>
 
 <br>

	
인터럽트에는 두 종류가 있다.

하나는 하드웨어 인터럽트이고 하나는 소프트웨어 인터럽트이다.

하트웨어 인터럽트는 외부 하드웨어 장치가 보내는 전기신호이다. 그것은 OS의 관심이 필요하다는 뜻이다. 예를들면 마우스 움직임이나 키보드의 입력이다.
인터럽트가 발생하면 프로세서는 반드시 멈추고 해당 하드웨어 디바이스가 보내는 신호를 읽어야 한다.

하드웨어 인터럽트에선 모든 장치는 IRL (interrupt request line)에 연결돼있어야 한다.

하드웨어 IRQ는 특정 디바이스와 연관된 값을 가지고 있다. 이것은 프로세서가 어떤 디바이스의 요청인지 파악하기 위해 반드시 필요하다.

하드웨어 인터럽트에는 크게 세가지 종류가 있다.

첫번째는 maskable interrupt이다. 인터럽트 마스크는 선택적으로 하드웨어 request를 실행가능하게 또는 아니게 만들 수 있다. 마스크비트가 set으로 돼있으면 인터럽트가  가능하고 아닐경우에는 인터럽트가 불가능하게 설정할 수 있다.

Non maskable interrupt는 인터럽트 마스크로는 인터럽트를 저지할 수 없는 인터럽트이다. 이런 인터럽트는 보통 중요도가 높은 인터럽트가 설정돼있따.

spurious interrupt 는 소스를 알 수 없는 인터럽트이다. 이 인터럽트는 시스템이 잘못 동작하는지 식별하기 매우 어렵다.

인터럽트에는 소프트웨어 인터럽트도 존재한다.

소프트웨어 인터럽트는 주로 디바이스 드라이버와 상호소통하거나 OS의 서비스를 요청할때 사용된다. 또는 특정 서비스를 요청하거나 프로그램을 종료할때도 발생할 수 있다.

인터럽트와 폴링의 차이는 폴링은 cpu 주기적으로 모든 디바이스의 상태를 체크하는 것이다.  디바이스의 IRQ비트를 확인하고 IRQ가 발견되면 그에 맞는 ISR을 실행한다. 하지만 cpu가 프로세싱 시간을 풀링에 사용하기 때문에 불필요한 cycle 낭비가 이뤄진다.  그 시간동안 다른작업을 할 수 없어 비효율적이다.

cpu polling은 프로토콜이고 하드웨어 메커니즘은 아니다. 반면 인터럽트는 하드웨어 메커니즘이다.

##### 인터럽트 동작 순서

1. 인터럽트 요청

2. 프로그램 실행 중단 -> CPU 연산을 중단한다 (일시정지) 이때 PCB, PC라는 개념이 등장한다.

중단하게 되면 현재상태를 백업하게 되는데 상태를 저장하기 위해 사용된다.

4. 인터럽트 처리 루틴 실행
 
6.  인터럽트가 발생하면 인터럽트 서비스 루틴(ISR)이 실행된다.

7. 상태복구 인터럽트 발생시 저장해둔 PC를 복구한다.

idt나 벡터 테이블은 ISR이 주어졌을떄 사용된다. 단 하나의 ISR이 IRQ랑 연결될 수 있다. 

interrut vector table은 real mode에서 사용되며 ISR에 대한 포인터를 가지고 있다. 그래서 모든 종류의 인터럽트는 이 테이블을 통해서 적절한 ISR을 찾아가게 된다. 

IDT는 protected mode에서 사용된다. IVT와 마찬가지로 ISR에 대한 포인터를 가지고 있으며 항상 physical memory에 상주해 있어야한다. 절대로 가상 메모리로 스왑 out 돼서는 안된다. 

</details>



### system call은 어떻게 kernel과 변수를 교환할까?
<details>
   <summary> 자세히 보기 </summary>
	
시스템 콜이 커널에게 제어권을 넘겨줄때 시스템 콜은 함수 실행에 필요한 파라미터를 전달해야될 때가 생길 수 있다.

그때 시스템 콜은 매개변수를 어떻게 넘길 수 있을까?

방법은 대표적으로 두가지가 있다. 하나는 레지스터를 통해 전달하는 것 두번째는 스텍 메모리에 저장하는 것이다.

레지스터에 전달하는 것은 register에 값을 저장하는 특별한 assemly langauge를 통해서 값이 쓰인다.

```
mov eax, 42      ; move the immediate value 42 into the eax register
```

스택을 통해 전달되는 것은 main memory를 통해서 전달되는 것이다. user application이 매개변수를 스택에 push하고 커널이 스택에서 데이터를 pop 하는것이다. 

시스템 콜이 발생하여 커널모드로 넘어가게 되면 커널은 현재 프로세스의 메모리공간에 엑세스 하여 스택 포인터 레지스터를 활용하여 스택에서 시스템 콜 파라미터를 찾습니다.

운영체제마다 다르겠지만 x86 같은 경우 %rdi, %rsi, %rdx, %rcx, %r8 및 %r9라고 불리는 6개의 레지스터에 시스템 콜 파라미터가 담기게 되고 6개가 넘어가게 되면 일반적으로 스택에 매개변수를 담게 됩니다.

시스템 콜의 리턴값도 역시 레지스터나 메모리 주소로 리턴이 되게 됩니다.

자바같은 경우 시스템콜을 발생시키기 위해 JNI를 사용하여 C또는 어셈블리로 작성된 코드를 호출합니다. native method는 특정한 instruction을 실행시켜 제어권을 JVM으로부터 OS kernel로 바꿔줍니다. 

OS kernel이 연산을 모두 수행하면 trap이나 interrupt를 발생시켜 제어권을 돌려줍니다. native method는 해당 결과값을 받아서 자바 프로그램에게 돌려줍니다. 


 <br>


</details>
