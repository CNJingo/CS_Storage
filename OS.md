# 운영체제


   
   
</details>

### non blocking vs blocking & sync vs asnyc
<details>
   <summary> 자세히 보기 </summary>
 
 <br>
   blocking과 non-blocking의 주요한 차이는 제어권을 가지고 있느냐 호출한 함수에게 넘기느냐 입니다.
  
  제어권을 호출한 함수에게 넘기게 된다면 호출자는 호출한 함수가 끝날때까지 기다려야 합니다.
  
  하지만 non blocking은 제어권을 넘기지 않기 때문에 해당 함수를 호출해놓고 본인이 해야될 일을 그대로 진행할 수 있습니다.
  
  sync와 async는 결과의 처리관점에서 보면 됩니다.
  
  sync는 호출한 함수가 반환한 결과를 바로 처리해야 하지만 asnyc같은 경우 호출한 함수의 결과값을 그 즉시 처리해도 되고 안해도 됩니다.
  
</details>

### process란?
<details>
   <summary> 자세히 보기 </summary>
 
 <br>
   프로세스란?

프로세스가 존재하기전에 프로그램이 존재한다.

프로그램을 실행했을때 프로그램의 인스턴스가 프로세스이다.

운영체제 입장에서는 프로세스화 시켜서 실행시킨다

이를 개념적으로 Task라고 한다.

컴퓨터에는 여러가지 프로세스들이 실행되고 있다.

이것들을 확인해보면 각각의 프로세스는 양의 정수로 이루어진 PID를 가지고 있다.

실행을 한다는 것을 일을 처리하는 것으로 볼 수 있다.

보통 운영체제는 여러개의 프로세스를 사용한다. 이 것을 Multi-tasking이라고 한다.

CPU에서 핀 하나가 전선 한가닥이다. 전기가 흐르면 1 전기가 흐르지 않으면 0이다. 그럼 핀 32개를 묶으면 32비트가 되는 것이다. 32비트에서 그런 어떤 곳엔 전기를 주고 어떤 곳엔 안주면 0010011...의 이진수 묶음이 생길 것이다. 입력을 담당하는 핀과 출력을 담당하는 핀도 존재한다. 입력을 받아서 특정한 연산을 쭉 해서 출력하는 것이 프로그램이다.

해당 연산들의 묶음을 하드디스크에 갖고 있으면 프로그램이고 그것을 복사해서 메모리에 올려서 진짜 연산을 시작하는 행위를 소위 '실행' 이라고 얘기한다.

프로그램이 실행하기 위해서는 커널을 통해서 필요한 하드웨어 자원을 할당받는다.

CPU와 램메모리의 일부를 할당 받게 된다. 만약 추가적으로 메모리 공간이 필요하다면 OS가 추가적인 메모리를 선택해서 준다. 이는 연속적이지 않을 수 있다.

	그리고 프로세스와 커널을 격리시키면 이것이 도커 컨테이너가 되는 것이다.

</details>

### system call
<details>
   <summary> 자세히 보기 </summary>
 
 <br>
	
컴퓨터는 유저모드, 커널모드, 하드웨어단 이렇게 세가지로 크게 범주화시킬 수 있다. 유저모드에서는 보통 시스템콜을 wrapping한 함수를 사용하여 시스템 콜을 호출하게 된다. 시스템콜을 호출하는 이유는 유저모드에서는 몇몇 명령어에 대한 권한이 없기 떄문이다. 예를 들면 memory read, write, jump to address와 같은 명령어들이다. 이러한 명령어는 커널모드에게 요청해서 커널이 대신 실행하게 해야한다. 이때 사용하는 것이 바로 시스템콜이다.

시스템 콜을 사용하면 CPL(Current Privilege Level)이라고 불리는 2비트 flag가 CS register에 저장돼있다. 이 CS register의 값이 3이면 유저모드, 0이면 커널모드이기 때문에 시스템콜이 발생하면 이 값을 0으로 바꾼다.
	
그 다음 스텍 세그먼트가 더이상 유저 스택을 가르키지 않는다. 스택에는 두 개의 공간이 나워져있는데 하나는 유저 모드 스택이고 하나는 커널 모드 스택이다. 
	
기본적으로 이는 커널모드에서 사용하는 정보와 유저모드를 구분해서 보호하기 위함이다. 이 것을 흔히 듀얼모드라고 부른다. 사용자모드와 커널모드를 나눠논 것을 얘기한다. 유저모드에서 privilieged instruction을 실행하는 것을 막아서 시스템을 보호한다.

이렇게 유저모드에서 커널모드로 변경시키는 작업을 인터럽트를 통해서 진행한다.

인터럽트는 IDT라는 interrupt descriptor table에 의해서 처리된다. 

IDT는 인터럽트와 인터럽트가 발생했을때 OS가 실행해야될 function이 맵핑되어 있다.

시스템 콜을 발생시키기 위해 x86 cpu는 int $0x80 명령어를 실행시킨다. int는 인터럽트를 뜻하며 0x80은 idt table의 위치를 나타낸다.

그리고 시스템콜 호출이 일반적인 함수호출과 다른 한가지 중요한 점은 일반적인 함수호출은 argument를 스택에 보내는 반면 시스템콜은 유저모드와 다른 스택을 사용하기 떄문에 이러한 방법이 불가능하다. 그렇기 떄문에 시스템 콜의 argument는 register에 저장한다. 만약 레지스터개수보다 파라미터 개수가 많다면 파라미터가 저장된 블록의 주소를 레지스터로 전달한다.

시스템 콜에는 다섯가지 종류가 존재한다.

Process control 
- 프로세스 종료와 생성
- 프로그램 로드 및 실행
- Wait 그리고 Signal event
- free memory 할당

File Management
- 파일 생성과 삭제, 열고 닫기, read / write, 파일 특성 가져오기

Device Management
- 디바이스에 요청하기
- 논리적으로 디바이스와 연결 또는 연결해제 하기
- 디바이스 특성 가져오기

Information Maintenance
- 시간 설정 및 가져오기
- 프로세스나 디바이스의 특성 가져오기

Communications
- connection 생성
- 메시지 주고 받기
- remote device와 연결 또는 해제하기



	



	
<img width="1365" alt="스크린샷 2022-12-11 오전 11 54 08" src="https://user-images.githubusercontent.com/55564829/206884132-5ada8bb7-6973-4861-84da-6b1e663eefdb.png">

 
</details>
